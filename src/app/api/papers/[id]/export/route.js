import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import puppeteer from 'puppeteer';

export async function POST(request, { params }) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    const { id } = await params;
    const { format = 'pdf' } = await request.json();

    const paper = await prisma.paper.findUnique({
      where: { id },
      include: {
        questions: { orderBy: [{ section: 'asc' }, { questionNumber: 'asc' }] },
        book: { select: { title: true } },
        createdBy: { select: { name: true, institution: { select: { name: true } } } },
      },
    });

    if (!paper) return NextResponse.json({ error: 'Not found' }, { status: 404 });

    // Group questions
    const grouped = {};
    paper.questions.forEach(q => {
      if (!grouped[q.section]) grouped[q.section] = [];
      grouped[q.section].push(q);
    });

    const sectionLabels = { A: 'Multiple Choice Questions', B: 'Short Answer Questions', C: 'Long Answer Questions' };

    // Build HTML
    const html = `<!DOCTYPE html>
<html lang="${paper.language === 'urdu' ? 'ur' : 'en'}" dir="${paper.language === 'urdu' ? 'rtl' : 'ltr'}">
<head>
  <meta charset="UTF-8">
  <title>${paper.title}</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&family=Inter:wght@400;600;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: '${paper.language === 'urdu' ? 'Noto Nastaliq Urdu' : 'Inter'}', serif; padding: 40px; font-size: 13px; color: #111; }
    .header { text-align: center; border-bottom: 3px double #333; padding-bottom: 16px; margin-bottom: 20px; }
    .header h1 { font-size: 20px; font-weight: 700; margin-bottom: 6px; }
    .header .meta { display: flex; justify-content: center; gap: 24px; font-size: 12px; color: #444; flex-wrap: wrap; margin-bottom: 6px; }
    .instructions { font-style: italic; font-size: 11px; color: #666; margin-top: 8px; }
    .section-header { background: #f0f0f0; padding: 8px 12px; margin: 20px 0 12px; border-left: 4px solid #4f46e5; font-weight: 700; }
    .section-title { font-size: 13px; }
    .section-sub { font-size: 11px; font-weight: 400; color: #666; }
    .question { padding: 8px 0; border-bottom: 1px solid #eee; }
    .question-text { margin-bottom: 4px; line-height: 1.5; }
    .options { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; padding-left: 24px; margin-top: 6px; font-size: 12px; color: #444; }
    .page-ref { font-size: 10px; color: #6366f1; margin-top: 3px; }
    .marks { float: right; font-weight: 600; color: #333; font-size: 11px; }
    .footer { border-top: 1px solid #ccc; margin-top: 30px; padding-top: 10px; text-align: center; font-size: 10px; color: #888; }
    @media print { body { padding: 20px; } }
  </style>
</head>
<body>
  <div class="header">
    ${paper.schoolName ? `<h2>${paper.schoolName}</h2>` : ''}
    <h1>${paper.title}</h1>
    <div class="meta">
      ${paper.paperPurpose ? `<span><strong>Purpose:</strong> ${paper.paperPurpose}</span>` : ''}
      <span><strong>Class:</strong> ${paper.classLevel}</span>
      <span><strong>Subject:</strong> ${paper.subject || 'N/A'}</span>
      <span><strong>Total Marks:</strong> ${paper.totalMarks}</span>
      <span><strong>Time:</strong> ${paper.timeDuration || 'N/A'}</span>
      ${paper.bookName ? `<span><strong>Book/Test:</strong> ${paper.bookName}</span>` : ''}
      <span><strong>Date:</strong> _______________</span>
    </div>
    ${paper.instructions ? `<div class="instructions">${paper.instructions}</div>` : ''}
  </div>

  ${Object.entries(grouped).map(([section, questions]) => `
    <div class="section-header">
      <div class="section-title">Section ${section}: ${sectionLabels[section] || 'Questions'}</div>
      <div class="section-sub">${questions[0]?.questionType === 'mcq'
        ? 'Choose the correct answer.'
        : `Attempt ${questions.length} questions. (${questions[0]?.marks} marks each)`}</div>
    </div>
    ${questions.map(q => `
      <div class="question">
        <div class="question-text">
          <span class="marks">[${q.marks} marks]</span>
          <strong>Q${q.questionNumber}.</strong> ${q.questionText}
        </div>
        ${q.options ? `<div class="options">
          ${(() => { try { return JSON.parse(q.options).map((o, k) => `<span>(${String.fromCharCode(97 + k)}) ${o}</span>`).join(''); } catch { return ''; } })()}
        </div>` : ''}
      </div>
    `).join('')}
  `).join('')}

  <div class="footer">
    Generated by ExamGen AI • aiclinix.online • ${new Date().toLocaleDateString()}
  </div>
</body>
</html>`;

    // Generate PDF with Puppeteer
    let browser;
    try {
      browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage'],
      });

      const page = await browser.newPage();
      await page.setContent(html, { waitUntil: 'networkidle0' });

      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: { top: '15mm', bottom: '15mm', left: '15mm', right: '15mm' },
      });

      await browser.close();

      // Update paper status
      await prisma.paper.update({
        where: { id },
        data: { status: 'exported' },
      });

      // Log analytics
      await prisma.analytics.create({
        data: {
          eventType: 'paper_exported',
          userId: session.user.id,
          metadata: JSON.stringify({ paperId: id, format }),
        },
      });

      return new NextResponse(pdfBuffer, {
        headers: {
          'Content-Type': 'application/pdf',
          'Content-Disposition': `attachment; filename="${paper.title.replace(/[^a-z0-9]/gi, '_')}.pdf"`,
          'Cache-Control': 'public, max-age=3600',
        },
      });
    } catch (puppeteerError) {
      if (browser) await browser.close();
      console.error('Puppeteer error:', puppeteerError);

      // Fallback: return HTML
      return new NextResponse(html, {
        headers: {
          'Content-Type': 'text/html',
          'Content-Disposition': `attachment; filename="${paper.title}.html"`,
        },
      });
    }
  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json({ error: 'Export failed' }, { status: 500 });
  }
}
